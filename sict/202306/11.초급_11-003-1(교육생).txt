1 ~ 45 중 임의의 숫자를 사용자에게 입력 받아 최대 6회 시도해서 맞추세요.
문제 해결을 위해 인터넷 검색 가능합니다.

. 작업 방식
- 사용자에게 임의의 숫자 한개를 입력 받는다.
- 프로그램으로 임의의 숫자를 1개 생성(생성 규칙 필요)
- 생성한 숫자를 판단(판단 결과: 크다, 작다, 정답)
- 정답이 나올 때까지 숫자 생성을 6번까지 할 수 있다.


. 제약 사항
- Write Line을 이용해서 입력 받은 숫자 표시
- Write Line을 이용해서 입력 받은 숫자 맞출 경우 "정답" 표시
- 사용자가 1~45 숫자 중 어떠한 숫자를 입력 하더라도 프로그램이 100% 맞추어야 한다.

- 제한조건 (검사받으면서 알아낸사항)
1. 6번안에 맞추려면 중간값을 찾아야하는데 풀이할때 중간값을 올림 내림으로 로직을 나누면 안되고 하나로 통일
2. 최소값, 최대값을 바꿔주면서 풀어야하는데 여기서 +1-1을 해주면 안된다.


- 이유찾기
1. 랜덤이 필요없는 이유
6번안에 찾으려면 중간값으로 찾아야한다

2. 반올림을 하면 안되는 이유
- 반올림을 하면
앞자리가 홀수면 올림처리되어 1.5가 2가 돼서 1을 찾을 수 없다
앞자리가 짝수면 내림처리돼서 44.5가 44가 돼서 45를 찾을 수 없다

반올림은 사용할수없으니 올림이나 내림을 해주어야한다.

3. +1-1 하는 이유
소수점을 처리하기위해 올림이나 내림을 해주어야하는데 
- 올림을 하면
45를 구할 수 있게 되지만 1을 못구하게 돼서 최소값에서-1을 해주어야한다.
- 내림을 하면
1을 구할 수 있게 되지만 45를 못구하게 돼서 최대값에서+1을 해주어야한다.

최대최소에서 +1-1을 해주는 이유는
minNum: 1, midNum: 23, maxNum: 45
minNum: 23, midNum: 34, maxNum: 45
minNum: 34, midNum: 39, maxNum: 45
minNum: 39, midNum: 42, maxNum: 45
minNum: 42, midNum: 43, maxNum: 45
minNum: 43, midNum: 44, maxNum: 45
44.xxxx가 반복되기 때문에 45를 구할수 없어서 최대값을 +1 해주지만
최대값을 +1 해주면 2.xxxx가 반복돼서 1을 못구하게되서 최소값을 -1 해줘야한다.

그리하여 올림내림 상관없이 하려면
최대값에서 +1을 해주고 최소값에서 -1을 해주어야한다.
그리하여 
반복을 도는중에 +1-1을 해주거나 (1번방법)
범위조건에 +1-1을 해줘야한다. (2번방법)

4. 증감연산자에서 +1-1을 하면 안되는 이유 2가지
4.1
1<=n<=45
23<n<=45

23은 정답과 비교해서 이미 체크했기 때문에 <로 해주면 규칙이 깨지게 된다.
규칙이 깨진다는 것은 조건식을 고쳐줘야 한다는 의미이다.
4.2 증감연산자는 매번해주어야해서 개선해줘야하는 단점도 있다.

  개선 (2번방법)
0<n< 46
23<n<46
34<n<46
40<n<46
43<n<46
44<n<46
45<n<46









