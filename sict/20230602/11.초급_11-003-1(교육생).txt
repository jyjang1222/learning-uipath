1 ~ 45 중 임의의 숫자를 사용자에게 입력 받아 최대 6회 시도해서 맞추세요.
문제 해결을 위해 인터넷 검색 가능합니다.

. 작업 방식
- 사용자에게 임의의 숫자 한개를 입력 받는다.
- 프로그램으로 임의의 숫자를 1개 생성(생성 규칙 필요)
- 생성한 숫자를 판단(판단 결과: 크다, 작다, 정답)
- 정답이 나올 때까지 숫자 생성을 6번까지 할 수 있다.


. 제약 사항
- Write Line을 이용해서 입력 받은 숫자 표시
- Write Line을 이용해서 입력 받은 숫자 맞출 경우 "정답" 표시
- 사용자가 1~45 숫자 중 어떠한 숫자를 입력 하더라도 프로그램이 100% 맞추어야 한다.

- 제한조건 (검사받으면서 알아낸사항)
1. 6번안에 맞추려면 중간값을 찾아야하는데 풀이할때 중간값을 올림 내림으로 로직을 나누면 안되고 하나로 통일
2. 최소값, 최대값을 바꿔주면서 풀어야하는데 여기서 +1-1을 해주면 안된다.

- 이유찾기
1. 랜덤이 필요없는 이유
6번안에 찾으려면 중간값으로 찾아야한다

2. +1-1하면 안되는 이유
조건을 수정해주면
매번 증감연산자로 +1-1를 해줄 필요가 없다.

1<=n<=45
23+1<=n<=45 - 
34(.5)+1<=n<=45  -> 34.5~35 손실
40+1<=n<=45
43+1<=n<=45
44(.5)+1<=n<=45

0<n< 46
23<n<46
34(.5)<n<46   ->  34.5~35 값 유지
40(.25)<n<46
43(.125)<n<46
44(.5626)<n<46
45(.28125)<n<46

3. 반올림을 하면 안되는 이유
- 반올림을 하면
앞자리가 홀수면 올림처리되어 1.5가 2가 돼서 1을 찾을 수 없다
앞자리가 짝수면 내림처리돼서 44.5가 44가 돼서 45를 찾을 수 없다
- 올림을 하면
45를 구할 수 있게 되지만 1을 못구하게 된다.
- 내림을 하면
1을 구할 수 있게 되지만 45를 못구하게 된다.

4. 1<=n<=45 의 조건을 변경해서 0<n<46으로 변경해서 해결했지만
  기존
1<=n<=45
23<=n<=45
34<=n<=45
39(.5)<=n<=45
42(.25)<=n<=45
43(.625)<=n<=45
44(.3125)<=n<=45
44..가 계속반복돼서 45를 못구함

  개선
0<n< 46
23<n<46
34(.5)<n<46   ->  34.5~35 값 유지
40(.25)<n<46
43(.125)<n<46
44(.5626)<n<46
45(.28125)<n<46
4.1 2<=n<=46으로 하면 다시 특정값을 못구하는 경우가 생김
2<=n<=46
24<=n<=46
35<=n<=46
40(.5)<=n<=46
43(.25)<=n<=46
44(.625)<=n<=46
45(.3125)<=n<=46
45(.xx)<=n<=46
45.. 계속반복 46 못구함

+1을 하게되면
2<=n<=46
24+1<=n<=46
35+1<=n<=46
41+1<=n<=46
44+1<=n<=46
45+1<=n<=46

-1을 하게되면
2<=n<=46
2<=n<=24-1
2<=n<=12-1
2<=n<=6-1
2<=n<=3-1


